[toc]

# 计算机基础原理

## 1.计算机指令的运行

```
1. Ad(Address) 形式地址
2. DR(Data Register) 数据寄存器
3. AR(Address Register) 地址寄存器(MAR)
4. IR(Instruction Register) 指令寄存器
5. BR(Buffer Register) 缓冲寄存器(MBR)
5. ID(Instruction Decoder) 指令译码器
6. PC(ProgramCounter) 程序计数器（储存指令，程序可以访问）
1.取指令阶段
    取指令（Instruction Fetch，IF）阶段是将一条指令从主存中取到指令寄存器的过程。
    程序计数器PC中的数值，用来指示当前指令在主存中的位置。当一条指令被取出后，PC中的数值将根据指令字长度而自动递增：若为单字长指令，则(PC)+1àPC；若为双字长指令，则(PC)+2àPC，依此类推。
    //PC -> AR -> Memory
    //Memory -> IR  //为分析指令 计算机的操作码和地址码都会存着指令寄存器（IR）里面
2.指令译码阶段
    取出指令后，计算机立即进入指令译码（Instruction Decode，ID）阶段。
    在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。
    在组合逻辑控制的计算机中，指令译码器对不同的指令操作码产生不同的控制电位，以形成不同的微操作序列；在微程序控制的计算机中，指令译码器用指令操作码来找到执行该指令的微程序的入口，并从此入口开始执行。
    //                        { 1.Ad
    //Memory -> IR -> ID ->   { 2.PC变化 
    //                        { 3.CU（Control Unit）
3.访存取数阶段
    根据指令需要，有可能要访问主存，读取操作数，这样就进入了访存取数（Memory，MEM）阶段。
    此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。
    //Ad -> AR -> AD -> Memory
4.执行指令阶段
    在取指令和指令译码阶段之后，接着进入执行指令（Execute，EX）阶段。
    此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。为此，CPU的不同部分被连接起来，以执行所需的操作。
    例如，如果要求完成一个加法运算，算术逻辑单元ALU将被连接到一组输入和一组输出，输入端提供需要相加的数值，输出端将含有最后的运算结果。
    //Memory -> DR -> ALU 
5.结果写回阶段
    作为最后一个阶段，结果写回（Writeback，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取；在有些情况下，结果数据也可被写入相对较慢、但较廉价且容量较大的主存。许多指令还会改变程序状态字寄存器中标志位的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作。
    //DR -> Memory
6.循环阶段
    在指令执行完毕、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就接着从程序计数器PC中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令。
    //重复 1~5
    //遇hlt(holt on)停止
```

## 2.总线

地址总线的宽度就是处理机寻址范围，若地址总线为 n 位，则可寻址空间为 2 的 n 次方字节

# 程序语言基础

## 1.语法分析器

编译程序中语法分析器接受以单词为单位的输入，并产生有关信息供以后各阶段使用。**算符优先法、LR分析法和递归下降法**是几种常见的语法分析技术。LR分析法主要有SLR(1)、LR(0)、LR(1)和LALR(1)等4种，其中**LR(1**)的分析能力最强，**LR(0)**的分析能力最弱。

## 2.正规式

由a、b构造且仅包含偶数个a的串的集合用正规式表示为：

a*表示由0个或多个a构成的符号串集合，a|b表示符号串a、b构成的集合，ab表示符号串ab构成的集合。

## 3.逻辑表达式

| 运算符 | 运算规则 | 范例          | 结果  |
| :----- | :------- | :------------ | :---- |
| &      | 与       | false&true    | false |
| \|     | 或       | false\|true   | true  |
| ^      | 异或     | false^true    | true  |
| ！     | 非       | !false        | true  |
| &&     | 短路与   | false&&true   | false |
| \|\|   | 短路或   | false\|\|true | true  |

2．逻辑运算符的运算优先级
（1）逻辑非的优先级最高，逻辑与次之，逻辑或最低，即：
！（非） → &&（与） → ||（或）
**记忆口诀：not（非） and(与） or（或）**
（2）**与其它种类运算符的优先关系**
！→ 算术运算 → 关系运算 → &&→ || → 赋值运算





# 数据库设计



$$
σ3<4(R*S)=选取第三个属性值小于第四个属性值的元组
$$

$$
πA.C(R)=取r集中A和C的属性值
$$

## 1.sql访问控制

```
"%"表示字符串匹配 "_"表示支付匹配
```

**DISTINCT**是去掉重复的项目通常联通**HAVING COUNT**使用

**GROUPY BY** 通常与 **HAVING** 一起使用

査询条件 **Where** 与  **Having**  的区別：  Where  是针对单条记录的判断条件，而  Having  是针对分组之后的判断条件。

数据控制由**DBA**决定，DBMS的功能保证决定的执行。

***read***权限对应四个基础操作的权限

**references**限制创建关系时的定义外码的能力

**PUBLIC**:将权限赋给某个用户或者多个用户

**WITH GRANT  OPTION**:获得权限的用户可以将权限赋给其他用户；

**注：属性列 视图中没有ALTER INDEX 权限**

```mysql
例题：将S,P,J的所有操作权限赋予给用户User1和User2
语句：GRANT ALL PRIVILEGES ON TABEL S,P,J TO Usr1，User2；
```

```mysql
收回权限语句：
REVOKE ALL PRIVILEGES ON TABLE S,P,J FROM User1，User2；
```

## 2.嵌入式SQL

EXEC SQL<SQL 语句>'

## 3.规范化数据库

### 第一范式 - 1NF

遵循原子性。即，**表中字段的数据，不可以再拆分**。

先看一个不符合第一范式的表结构，如下：

| 员工编码 | 姓名       | 年龄 |
| -------- | ---------- | ---- |
| 001      | 销售部小张 | 28   |
| 002      | 运营部小黄 | 25   |
| 003      | 技术部小高 | 22   |

在这一个表中的，姓名 字段下的数据是可以再进行拆分的，因此它不符合第一范式，那怎么样才符合第一范式呢？如下：

| 员工编码 | 部门   | 姓名 | 年龄 |
| -------- | ------ | ---- | ---- |
| 001      | 销售部 | 小张 | 28   |
| 002      | 运营部 | 小黄 | 25   |
| 003      | 技术部 | 小高 | 22   |

那是否遵循第一范式就一定是好的呢？如下：

| 员工编码 | 姓名 | 地址               |
| -------- | ---- | ------------------ |
| 001      | 小张 | 江西省南昌市东湖区 |
| 002      | 小黄 | 广东省佛山市禅城区 |
| 003      | 小高 | 湖北省武汉市新洲区 |

通过观察上述表结构，我们发现，地址是可以再进一步拆分的，比如：

| 员工编码 | 姓名 | 省     | 市     | 区     |
| -------- | ---- | ------ | ------ | ------ |
| 001      | 小张 | 江西省 | 南昌市 | 东湖区 |
| 002      | 小黄 | 广东省 | 佛山市 | 禅城区 |
| 003      | 小高 | 湖北省 | 武汉市 | 新洲区 |

虽然拆分后，看上去更符合第一范式了，但是如果项目就只需要我们输出一个完整地址呢？那明显是表在没拆分的时候会更好用。

所以范式只是给了我们一个参考，我们更多的是要根据项目实际情况设计表结构。

### 第二范式 - 2NF

在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，**表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。**

再通俗点讲就是，**一个表只能描述一件事情**。

我们用一个经典案例进行解析。

| 学号 | 姓名 | 年龄 | 课程名称 | 成绩 | 学分 |
| ---- | ---- | ---- | -------- | ---- | ---- |
| 001  | 小张 | 28   | 语文     | 90   | 3    |
| 001  | 小张 | 28   | 数学     | 90   | 2    |
| 002  | 小黄 | 25   | 语文     | 90   | 3    |
| 002  | 小黄 | 25   | 语文     | 90   | 3    |
| 003  | 小高 | 22   | 数学     | 90   | 2    |

我们先分析一下表结构。

\1. 假设学号是表中的唯一主键，那由学号就可以确定姓名和年龄了，但是却不能确定课程名称和成绩。

\2. 假设课程名称是表中的唯一主键，那由课程名称就可以确定学分了，但是却不能确定姓名、年龄和成绩。

\3. 虽然通过学号和课程名称的联合主键，可以确定除联合主键外的所有的非主键值，但是基于上述两个假设，也不符合第二范式的要求。



那我们应该**如何调整表结构**，让它能复合第二范式的要求呢？

我们可以**基于上述的三种主键的可能，拆分成 3 张表，保证一张表只描述一件事情**。

\1. 学生表 - 学号做主键

| 学号 | 姓名 | 年龄 |
| ---- | ---- | ---- |
| 001  | 小张 | 28   |
| 002  | 小黄 | 25   |
| 003  | 小高 | 22   |

\2. 课程表 - 课程名称做主键

| 课程名称 | 学分 |
| -------- | ---- |
| 语文     | 3    |
| 数学     | 2    |

\3. 成绩表 - 学号和课程名称做联合主键

| 学号 | 课程名称 | 成绩 |
| ---- | -------- | ---- |
| 001  | 语文     | 90   |
| 001  | 数学     | 90   |
| 002  | 语文     | 90   |
| 002  | 语文     | 90   |
| 003  | 数学     | 90   |



这时候我们可能会想，为什么我们就要遵循第二范式呢？**不遵循第二范式会造成什么样的后果呢**？

\1. 造成整表的数据冗余。

如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址......如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。

\2. 更新数据不方便。

假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。

\3. 插入数据不方便或产生异常。

① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。

② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。

###第三范式 - 3NF

在满足第二范式的情况下，消除传递依赖。即，**在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B**。

仍然用一个经典例子来解析

| 学号 | 姓名 | 班级          | 班主任 |
| ---- | ---- | ------------- | ------ |
| 001  | 小黄 | 一年级（1）班 | 高老师 |

这个表中，学号是主键，它可以唯一确定姓名、班级、班主任，符合了第二范式，但是在非主键字段中，我们也可以通过班级推导出该班级的班主任，所以它是不符合第三范式的。

那怎么设计表结构，才是符合第三范式的呢？

\1. 学生表

| 学号 | 姓名 | 班级          |
| ---- | ---- | ------------- |
| 001  | 小黄 | 一年级（1）班 |

\2. 班级表

| 班级          | 班主任 |
| ------------- | ------ |
| 一年级（1）班 | 高老师 |

通过把班级与班主任的映射关系另外做成一张映射表，我们就成功地消除了表中的传递依赖了。

##BCNF：

如果关系模式R（U，F）的所有属性（包括主属性和非主属性）都不传递依赖于R的任何候选关键字，那么称关系R是属于BCNF的。或是关系模式R中，每个决定因素都包含关键字（而不是被关键字所包含）。

### 总结

不知道读者们有没有发现，以上所介绍的范式的最终目的都是为了减少我们的工作量呢？所以说，尽管范式是一种很好的指导规范，但在实际应用中，我们也不需要太局限在范式中，更多的是应该从项目中出发，设计出合理的表结构。

以下是本篇三范式的简单总结：

- 第一范式（1 NF）：字段不可再拆分。
- 第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。
- 第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。

- BCNF:模式内任何数都没有依赖传递

##4.数据流程图和ER图

  简称：ERD：ER图（实体，属性，联系，弱实体（指某些实体对于另一些实体有很强的依赖关系）） DFD：数据流图（外部实体，数据流，加工，数据存储）

## 5.关系式

### Armstrong 公理

- **合并规则**：若X→Y，X→Z同时在R上成立，则X→YZ在R上也成立。

- **分解规则**：若X→W在R上成立，且属性集Z包含于W，则X→Z在R上也成立。

- **伪传递规则**：若X→Y在R上成立，且WY→Z，则XW→Z。

  Armstrong公理系统设关系模式R<U,F>，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则：

  A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；
  A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；
  A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。
  根据上面三条推理规则，又可推出下面三条推理规则：

  合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；
  伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；
  分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。
  引理：X→A1A2…Ak成立的充分必要条件是X→Ai成立(i=1,2,…,k)。

  ####Armstrong公理系统的证明

  A1自反律：若Y X U，则X→Y为F所蕴含
  证明1
  设Y⊆X⊆U。
  对R<U,F>的任一关系r中的任意两个元组t,s：
  若t[X]=s[X]，由于Y X，则有t[Y]=s[Y]，所以X→Y成立，自反律得证。

  A2增广律：若X→Y为F所蕴含，且Z U，则XZ→YZ为F所蕴含
  证明2
  设X→Y为F所蕴含，且Z⊆U。
  对R<U,F>的任一关系r中的任意两个元组t,s：
  若t[XZ]=s[XZ]，由于X ⊆XZ，Z⊆ XZ，根据自反律，则有t[X]=s[X]和t[Z]=s[Z]；
  由于X→Y，于是t[Y]=s[Y]，所以t[YZ]=s[YZ]；所以XZ→YZ成立，增广律得证。

  A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含
  证明3
  设X→Y及Y→Z为F所蕴含。
  对R<U,F>的任一关系r中的任意两个元组t,s：
  若t[X]=s[X]，由于X→Y，有t[Y]=s[Y]；
  再由于Y→Z，有t[Z]=s[Z]，所以X→Z为F所蕴含，传递律得证。

  合并规则：若X→Y，X→Z，则X→YZ为F所蕴含
  证明4
  因X→Y ，所以X→XY （增广律 XX→XY即X→XY）
  因X→Z ，所以XY→YZ （增广律）
  因X→XY，XY→YZ
  故X→YZ （传递律）

  伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含
  证明5
  因X→Y ，所以WX→WY （增广律）
  因WY→Z ，所以XW→Z （传递律）

  分解规则：若X→Y，Z∈Y，则X→Z为F所蕴含
  证明6
  因Z∈Y 　所以Y→Z （自反律）
  因X→Y 所以X→Z （传递律）

## 6.存储概念

**注意**：数据库管理系统利用日志文件来进行事务故障恢复和系统故障恢复。在事务处理过程中，DBMS把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入日志文件。当系统正常运行时，按一定的时间间隔，把数据库缓冲区内容写入数据文件；一旦发生故障，DBMS的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。

常见的摘要算法有：MD5、SHA等MD5：信息摘要算法第五版，输入以512位为分组，进行处理，产生一个128位的输出。

分片透明性是指用户不必关系数据是如何分片的，它们对数据的操作在全局关系上进行，即关系如何分片对用户是透明的，因此，当分片改变时应用程序可以不变。分片透明性是最高层次的透明性，如果用户能在全局关系一级操作，则数据如何分布，如何存储等细节自不必关系，其应用程序的编写与集中式数据库相同。 

复制透明：用户不用关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。在分布式数据库系统中，可以把一个场地的数据复制到其他场地存放，应用程序可以使用复制到本地的数据在本地完成分布式操作，避免通过网络传输数据，提高了系统的运行和查询效率。但是对于复制数据的更新操作，就要涉及到对所有复制数据的更新。

位置透明性是指用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。因此，数据分片模式的改变，如把数据从一个站点转移到另一个站点将不会影响应用程序，因而应用程序不必改写。 

局部映像透明性（逻辑透明）是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关系局部 DBMS 支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。

![](C:\Users\668mik\Desktop\音乐播放器2\20230429222938.png)

DMBS 是数据库管理系统，主要用来保证数据库的安全性和完整性。而 DBA 通过授权功能为不同用户授权，主要的目的是为了保证数据的安全性。

一个满足BC范式的关系模式有： 所有非主属性对每一个码都是完全函数依赖； 所有主属性对每一个不包含它的码也是完全函数依赖； 没有任何属性完全函数依赖于非码的任何一组属性。

## sql语句

###order by 和group by 的区别

`ORDER BY` 和 `GROUP BY` 是 SQL 中常用的两个语句。

`ORDER BY` 是用来对查询得到的结果进行排序的。它可以根据表中的一个或多个列对结果进行排序，并且可以指定排序的顺序是升序还是降序。

`GROUP BY` 是用来将查询得到的结果分组的。它根据表中的一个或多个列将结果分成若干个组，每组都有相同的值。在使用 `GROUP BY` 时，通常需要使用聚合函数（如 `SUM`、`COUNT` 等）来对每组数据进行统计。

所以，”ORDER BY” 用来对结果集排序，而 “GROUP BY” 用来对结果集分组。

# 算法与结构

## 后缀式

###一、基本概念

1、中缀表达式：

        操作符以中缀形式位于运算数中间（如：3+2），是我们日常通用的算术和逻辑公式表示方法。

2、后缀表达式：

        又称逆波兰式（Reverse Polish Notation - RPN），操作符以后缀形式位于两个运算数后（如：3+2的后缀表达形式就是3 2 +）。

3、前缀表达式：

        又称波兰式（Polish Notation），操作符以前缀形式位于两个运算数前（如：3+2的前缀表达形式就是+ 3 2）。

中缀表达式往往需要使用括号将操作符和对应的操作数括起来，用于指示运算的次序

e.g：5*(2+1) 虽然 * 的优先级高于 +  ，但括号的存在表示应优先执行括号内的 + 运算。

中缀表达式适合于人类的思维结构和运算习惯，但并不适用于计算机

尤其是包含括号的中缀表达式，对计算机而言是非常复杂的结构。

适用于计算机的后缀表达式

与中缀表达式不同，后缀表达式不需要使用括号来标识操作符的优先级。

后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)，对于计算机而言是比较简单的结构。

###二、中缀表达式转后缀表达式
从左至右依次遍历中缀表达式各个字符（需要准备一个字符栈存储操作符和括号）

1、字符为 运算数 ：

直接送入后缀表达式（注：需要先分析出完整的运算数）。

2、字符为 左括号 ：

直接入栈（注：左括号入栈后优先级降至最低）。

3、字符为 右括号 ：

直接出栈，并将出栈字符依次送入后缀表达式，直到栈顶字符为左括号（左括号也要出栈，但不送入后缀表达式）。

总结：只要满足 栈顶为左括号 即可进行最后一次出栈。

4、字符为 操作符 ：

若栈空，直接入栈。

若栈非空，判断栈顶操作符，若栈顶操作符优先级低于该操作符，该操作符入栈；否则一直出栈，并将出栈字符依次送入后缀表达式，直到栈空或栈顶操作符优先级低于该操作符，该操作符再入栈。

总结：只要满足 栈空 或者 优先级高于栈顶操作符 即可停止出栈，并将该操作符入栈。

5、重复以上步骤直至遍历完成中缀表达式，接着判断字符栈是否为空，非空则直接出栈，并将出栈字符依次送入后缀表达式。

注：中缀表达式遍历完成，栈中可能还有字符未输出，故需要判断栈空。

## （最优二叉树）哈夫曼树的编码

1）将信源符号的概率按减小的顺序排队。 2）把两个最小的概率相加，并继续这一步骤，始终将较高的概率分支放在右边，直到最后变成概率１。 3）画出由概率１处到每个信源符号的路径，顺序记下沿路径的０和１，所得就是该符号的霍夫曼码字。  4）将每对组合的左边一个指定为0，右边一个指定为1（或相反）。



n个权值m个点 m=n*2-1

## 二叉树

###二叉树的性质

二叉树是一种树型数据结构，由节点和边构成，且每个节点最多有两个子节点。

二叉树具有以下性质：

1. 每个节点最多有两个子节点，这两个子节点分别称为左子节点和右子节点。
2. 左子树和右子树都是二叉树（可以为空）。
3. 对于任意一个节点，其左子树的所有节点值都小于该节点的值，右子树的所有节点值都大于该节点的值。这个性质也被称为二叉搜索树（BST）的性质。
4. 如果对于某个节点，其左子树和右子树的高度差都不超过1，则该二叉树称为平衡二叉树（AVL树）。

二叉树的性质是二叉树算法设计的基础，根据这些性质我们可以设计出各种高效的二叉树算法。

​    5.对于任何一个二叉树，其叶子结点为n0，度为二的点数为n2，则n0=n2+1。

​    6.具有n个结点的完全二叉树深度为log2n加一

​    7.空指针二叉链表：2n-(n-1)=n+1; 三叉链表：3n-(2n-2)=n+2

## hashmap

哈希表hashtable通过一个已记录的关键字为自变量的函数（哈希函数）得到该记录的存储地址，所以在哈希表中进行查找操作时，需用同一哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获得有关信息再判定查找是否成功。用哈希表存储元素时,需要进行冲突(碰撞)处理，这个冲突指的是关键字不同的元素被映射到相同的存储位置。

## 存储

散列存储结构。散列存储结构将结点按其关键字的散列地址存储到散列表中。常用的散列函数有除余法、基数转换法、平方取中法、折叠法、移位法和随机数法等。

![](C:\Users\668mik\Desktop\音乐播放器2\20230503230227.png)

## 时间复杂度与空间复杂度

时间复杂度
(1)时间频度
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

(2)时间复杂度
在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

大O符号表示法
首先我们先看一个例子

```
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```



通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?

在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)

为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。

常见的时间复杂度量级
常数阶O(1)
对数阶O(logN)
线性阶O(n)
线性对数阶O(nlogN)
平方阶O(n2)
立方阶O(n3)
K次方阶O(nk)
指数阶(2n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

下面选取一些常见的进行讲解

常数阶O(1)
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```


上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

线性阶O(n)
这个在最开始的代码示例中就讲解过了，如：

```
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

对数阶O(logN)

```
int i = 1;
while(i<n)
{
    i = i * 2;
}
```



从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)

线性对数阶O(nlogN)
线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：

```for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

平方阶O(n2)
平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
举例：

```for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)
如果将其中一层循环的n改成m，即：
```

```
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```



那它的时间复杂度就变成了 O(m*n)

立方阶O(n³)、K次方阶O(n^k)
参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。

二、空间维度
类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：

空间复杂度O(1)
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：

```
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

空间复杂度O(n)

```
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

# 操作系统

## 磁盘缓存

单缓冲区时间=完整时间+（读入时间+送至用户去时间）*（盘块数-1）

##PV操作
 P操作：相当于请求资源、输入

V操作：相当于释放资源、输出

在单一进程内部，由 P操作 —> V操作

1、P：请求到资源 (相当于程序输入)

2、执行…

3、V：释放资源 (相当于程序的输出)

在两个进程之间，由 V操作 —> P操作

1、V：一个进程释放了资源

2、P：另一个进程可以申请该资源

起始进程：只有 V操作(输出)，没有 P操作(输入)

相当于程序只出不进

终止进程：只有 P操作(输入)，没有 V操作(输出)

相当于程序只进不出

前趋图中信号排序规则：从左到右、从上到下，依次为1、2、3…

1）同步信号量，值为资源可以使用的个数，信号量小于0，则线程进行等待，信号量大于0，表示可用资源个数。初始值0. （2）互斥信号量只有两个值0或1，0表示资源正在被占用，线程等待。1表示，资源没有被使用，线程可以进入。初始值为1

## 字节运算

1kb等于1×8bit

## 存储&系统

###指令

RISC指令系统的最大特点是：选取使用频率最高的一些简单指令，指令条数少；指令长度固定，指令格式种类少，只有取数/存数指令访问存储器，其余指令的操作都在寄存器之间进行。

###i/o

在计算机中，I/O系统可以有5种不同的工作方式，分别是程序控制方式、程序中断方式、DMA工作方式、通道方式、I/O处理机。

1、程序控制方式分为无条件查询和程序查询方式。

①无条件传送方式，I/O端口总是准备好接受主机的输出数据，或是总是准备好向主机输入数据，而cpu在需要时，随时直接利用I/O指令访问相应的I/O端口，实现与外设的数据交换。优点是软、硬件结构简单，缺点是对时序要求高，只适用于简单的I/O控制。

②程序查询方式程序查询方式也称为程序轮询方式，该方式采用用户程序直接控制主机与外部设备之间输入/输出操作。CPU必须不停地循环测试I/O设备的状态端口，当发现设备处于准备好(Ready)状态时，CPU就可以与I/O设备进行数据存取操作。这种方式下的CPU与I/O设备是串行工作的。

2、中断方式当I/O设备结束(完成、特殊或异常)时，就会向CPU发出中断请求信号，CPU收到信号就可以采取相应措施。当某个进程要启动某个设备时，CPU就向相应的设备控制器发出一条设备I/O启动指令，然后CPU又返回做原来的工作。CPU与I/O设备可以并行工作，与程序查询方式相比，大大提高了CPU的利用率。

3、DMA(直接内存存取)方式DMA方式也称为直接主存存取方式，其思想是：允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须CPU的干预。

4、通道控制方式在一定的硬件基础上利用软件手段实现对I/O的控制和传送，更多地免去了cpu的接入，使主机和外设并行工作程度更高。

5、I/O处理机指专门负责输入/输出的处理机。可以有独立的存储器、运算部件和指令控制部件

### 页面置换

因为根据程序的局部性原理，最近未被访问的页面下次被访问的概率更小；如果页面最近

都被访问过，应该先淘汰未修改过的页面。因为未修改过的页面内存与辅存一致，故淘汰
时无需写回辅存，使系统页面置换代价小。

## 死锁

死锁条件为可用资源数小于（单个进程所需资源-1）*进程数+1

死锁四个必要条件

1.控制互斥

2.不可剥离

3. 占有和保持

4.环路

1、 互斥条件：
进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

2、不可剥夺条件:
进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

3、 请求与保持条件：
进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

4、循环等待条件:
存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。

冗余技术又称储备技术，它是利用系统的并联模型来提高系统可靠性的一种手段。冗余附加件包括：独立设计的相同功能冗余备份程序的存储及调用；实现纠错检测及恢复的程序；为实现容错软件所需的固化程序。

## cpu

CPU访问速度：通用寄存器>Cache>内存>硬盘

# 软件工程

软件工程是一种层次化的技术，从底向上分别为**质量、过程、方法和工具**。任何工程方法必须以有组织的质量承诺为基础。软件工程的基础是过程，过程是将技术结合在一起的凝聚力，使得计算机软件能够被合理地和及时地开发，过程定义了一组关键过程区域，构成了软件项目管理控制的基础；方法 提供了建造软件在技术上需要 &ldquo;如何做&rdquo;， 它覆盖了一系列的任务。方法也依赖于一些基本原则，这些原则控制了每一个技术区域 而且包含建模活动和其他描述技术；工具对过程和方法提供了自动或半自动的支持，如：计算机辅助软件工程（CASE）。软件工程的基本要素包括**方法、工具和过程**。

阶段式模型的结果类似于CMM(能力成熟度模型)，它关注组织的成熟度。其中定义了五个成熟度等级。初始的：过程不可预测且缺乏管理
已管理的：过程为项目服务
已定义的：过程为组织服务
定量管理的：过程已度量和控制
优化的：集中于过程改进
连续式模型
连续式模型关注每个过程域的能力，一个组织对不同的过程域可以的达到不同的过程域能力等级(Capability Level ,CL)。CMMI中包括6个过程域能力等级，等级为0~5，能力等级包括共性目标以及相关的共性实践，这些实践在过程域内被添加到特定目标和实践中。当组织满足过程域的特定目标和共性目标时，就说该组织达到了那个过程域的能力等级。能力等级可以独立地应用于任何单独的过程域，任何一个能力等级都必须满足比它等级低的能力等级的所有准则。

**能力等级描述：**
CL0(未完成的)：过程域未执行或未得到CL1中定义的所有目标。
CL1(已执行的)：其共性目标是过程将可识别的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。
CL2(已管理的)：其共性目标集中于以管理的过程的制度化。根据组织级政策规定过程的运作将使用那个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。
CL3(已定义的)：其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。
CL4(定量管理的)：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理理准则。
CL5(优化的)：使用量化手段改进和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。

**改进计划：**软件成熟度模型 CMM 是对软件组织进化阶段的描述，该模型在解决软件过程存在问题
方面取得了很大的成功，因此在软件界产生了巨大影响，促使软件界重视并认真对待过程
改进工作。过程能力成熟度模型基于这样的理念：改进过程将改进产品，尤其是软件产品
软件组织为提高自身的过程能力，把不够成熟的过程提升到较成熟的过程涉及 4 个方面，
这 4 个方面构成了软件过程改进的框架，即过程改进基础设施、过程改进线路图、软件过
程评估方法和软件过程改进计划。在进行评估后需要把发现的问题转化为软件过程改进计
划。而过程改进通常不可能是一次性的，需要反复进行。每一次改进要经历 4 个步骤：评
估、计划、改进和监控。

##up

统一过程(UP)的基本特征是用例和风险驱动，以架构为中心，受控的迭代式的增量开发。UP定义了四个阶段：起始阶段(inception)：该阶段的主要目的是建立项目的范围和版本，确定项目目标的可行性和稳定性，结交结果包括需求和用例。精化阶段(elaboration)：该阶段的目的是对问题域进行分析，建立系统需求和架构，确定实现的可行性和稳定性，提交结果包括系统架构，问题领域、修改后的需求及项目开发计划等相关文档。构建阶段(construction)：增量式开发可以交付给用户的软件产品。移交阶段(transition)：目的是将软件产品交付给用户。

其中初启阶段的里程碑是生命周期目标，精化阶段的里程碑是生
命周期架构，构建阶段的里程碑是初始运作功能，移交阶段的里程碑是产品发布。

##冗余

冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。
通常冗余技术分为 4 类：（

（1)结构冗余，按其工作方法可以分为静态、动态和混合冗余；
	（2)信息冗余，指的是为了检测或纠正信息在运算或传输中的错误另外加的一部分信息；
	（3)时间冗余，是指以重复执行指令或程序来消除瞬时错误带来的影响；

（4) 冗余附件技术，是指为实现上述冗余技术所需的资源和技术。

# 软件设计与体系结构

##Gantt 图和 PERT 图

软件项目计划的一个重要内容是Gantt 图和 PERT 图安排进度，常用的方法有 Gantt 图和 PERT 图。

Gantt图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和
任务之间的并行，但是不能清晰地描述各个任务之间的依赖关系。 

PERT 图是一种网络模型，描述一个项目任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才
能开始另一些任务，以及如期完成整个工程的关键路径。但不能反映任务之间的并行性，以及项目的当前进展情况。

**关键路径、总时差、松弛时间**
PEAT图能清晰描述每个任务从何时开始、到何时结束、各任务之间的依赖关系。
关键路径是图中源点至汇点的最长路径，关键路径的时间称之为项目工期，也表述为项目完成所需的最少时间。
总时差：在不延误总工期的前提下，该活动的机动时间，一般在图中，以最晚结束时间减去最早结束时间求取，或以最晚开始时间减去最早开始时间求取。
松弛时间：不影响完工前提下可能被推迟完成的最大时间。例如，求AB活动的松弛时间，先求AB活动通过的路径（如果有两条不同的路径应该选择最大的一条），用关键路径减去该路径的长度，表示该活动的松弛时间。

##UML

UML 类图中类与类之间的关系有五种：依赖、关联、聚合、组合与继承。依赖是几种
关系中最弱的一种关系，通常，使用类库就是其中的一种关系。聚合与组合都表示了整体
和部分的关系。组合的程度比聚合高，当整体对象消失时，部分对象也随之消失，则属于
组合关系，当整体对象消失而部分对象依然可以存在并继续被使用时，则属于聚合关系。

##敏捷过程

极限编程 XP 是激发开发人员创造性、使得管理负担最小的一组技术.。
水晶法 Crystal 认为每—个不同的项目都需要一套不同的策略、约定和方法论。
并列争球法(Scram)使用迭代的方法，其中把每 30 天一次的迭代称为个冲刺， 并按需求的
优先级来实现产品多个自组织和自治小组并行地递增实现产品，协调是通过简短的日常情
况会议进行。
自适应软件开发（ASD)有六个基本的原则：
①在自适应软件开发中，有一个使命作为指导，它设立了项目的目标，但不描述如何达到
这个目标；
②特征被视为客户键值的关键，因此，项目是围绕着构造的构件来组织并实现特征；
③过程中的迭代是很重要的，因此重做与做同样重要，变化也包含其中；
④变化不视为是一种更正，而是对软件开发实际情况的调整；
⑤确定的交付时间迫使开发人员认真考虑每一个生产版本的关键需求；
⑥风险也包含其中，它使开发人员首先跟踪最艰难的问题。

# 计算机安全

##病毒的分类和命名规则
　　1、病毒名称的一般格式：<病毒前缀>.<病毒名>.<病毒后缀>。
　　病毒前缀：病毒的种类，不同种类的病毒前缀不同。木马：Trojan、蠕虫:Worm。
　　病毒名：病毒的家族特征。CIH病毒家族名为“CIH”、震荡波蠕虫家族名为“Sasser”。
　　病毒后缀：用来区别某个家族病毒的的不同变种，一般用英文表示。Worm.Sasser.b就是指震荡波蠕虫的变种b。
　　2、常见类型：
　　(1)系统病毒：前缀为Win32、PE、Win95、W32、W95等。共同特性：感染windows操作系统的exe和dll，并通过这些文件进行传播。例如CIH病毒。
　　(2)蠕虫病毒：前缀为Worm。特性：通过网络或者系统漏洞进行传播，大比分蠕虫病毒都有向外发送带毒邮件、阻塞网络的特性。例如：冲击波、小邮差病毒。
　　(3)木马病毒：前缀为Trojan,黑客病毒前缀为Hack。特征：通过网络或系统漏洞进入系统并隐藏起来，然后向外界泄露用户的解密信息；而黑客病 毒则有一个可视界面，能对用户的计算机进行远程控制。木马和黑客病毒往往成对出现，木马负责侵入用户计算机，黑客通过木马病毒进行远程控制。两者趋于整合。
　　(4)脚本病毒：前缀是Script。特征：使用脚本语言编写，通过网页进行传播。
　　(5)宏病毒：特殊脚本病毒，前缀是Macro，第二前缀是Word，Word97，Excel，Excel97等。特征：感染office文档，通过office通用模版进行传播。凡是只感染Word97以及以前版本Word文档的病毒采用Wors97作为第二前缀，格式是Macro.Word97；凡是只感染Word97以后版本Word文档的病毒都采用Word作为第二前缀，格式是Macro.Word；凡是只感染Excel97及以前版本Execl文档病毒采用Excel97作为第二前缀，格式是Macro.Excel97；凡是只感染Excel97以后版本Excel文档的病毒采用Excel作为第二前缀，格式是Macro.Excel97，以此类推。

# 行业标准

##音频标准

MPEG-1、MPEG-2 和 MPEG-4 主要针对音、视频编码技术，而 MPEG-7 是多媒体内容描述
        接口标准，MPEG-21 是多媒体应用框架标准。
